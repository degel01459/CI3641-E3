# Ejercicio 2

**Autor:** Kevin Briceño (15-11661)

Se desea que modele e implemente, en el lenguaje de su elección, un programa que simule un manejador de tipos de datos. Este programa debe cumplir con las siguientes características:

(a) Debe saber manejar tipos atómicos, registros (struct) y registros variantes (union).

(b) Unaveziniciado el programa, pedirá repetidamente al usuario una acción para proceder.

Tal acción puede ser:

i. ATOMICO `<nombre><representación><alineación>`
Define un nuevo tipo atómico de nombre `<nombre>`, cuya representación ocupa `<representación>` bytes y debe estar alineado a `<alineación>` bytes.

Ejemplo: ATOMICO char 1 2 y ATOMICO int 4 4

ii. STRUCT `<nombre>[<tipo>]`
Define un nuevo registro de nombre `<nombre>`. La definición de los campos del registro viene dada por la lista en `[<tipo>]`. Nótese que los campos no tendrán nombres, sino que serán representados únicamente por el tipo que tienen.

Ejemplo: STRUCT foo char int

iii. UNION `<nombre>[<tipo>]`
Define un nuevo registro variante de nombre `<nombre>`. La definición de los campos del registro variante viene dada por la lista en `[<tipo>]`.

Ejemplo: UNION bar int foo int

iv. DESCRIBIR `<nombre>`
Debe dar la información correspondiente al tipo con nombre `<nombre>`. Esta información debe incluir tamaño, alineación y cantidad de bytes desperdiciados para  el tipo, bajo distintas estrategias:
Sin empaquetar.
Empaquetado.
Reordenando los campos de manera óptima.

v. SALIR
Debe salir del simulador.

El programa deberá pedir la siguiente acción al usuario después de cada ejecución.
Además, debe incluir pruebas unitarias con cobertura mayor al 80%.

## Resolución del Ejercicio 2

Para la solución de este problema se aplicó la teoría **Diseño de Memoria (Memory Layout)**:

### 1. Teoría Aplicada

* **Alineación ($K$):** Cada tipo de dato primitivo tiene un requisito de alineación. La dirección de memoria de inicio de un dato debe ser divisible por $K$.
* **Relleno (Padding):** Los compiladores insertan bytes "basura" entre campos para mantener la alineación. En el código, esto se calcula aritméticamente:
    $$Padding = (K - (OffsetActual \mod K))\mod K$$
* **Alineación de Estructuras:** El tamaño total de un `struct` debe ser múltiplo de la alineación más estricta de sus miembros para permitir arreglos contiguos sin romper alineación.
* **Estrategia Óptima:** ordenar los campos de **mayor a menor restricción de alineación** minimiza o elimina el padding interno.

### 2. Solución

El código se estructura en tres componentes principales:

1.  **Modelos (`DataType`):**
    * `AtomicType`: Representa tipos base (int, char).
    * `StructType`: Implementa la lógica compleja de layout. Contiene el método `calculate_layout` que simula el recorrido del puntero de memoria (`current_offset`), sumando tamaños y calculando el padding dinámicamente según la estrategia elegida.
    * `UnionType`: Implementa la lógica de superposición de memoria. Su tamaño es el del campo más grande, ajustado al múltiplo de su alineación.

2.  **Controlador (`TypeManager`):**
    * Actúa como una *Tabla de Símbolos*. Mantiene un registro (`dictionary`) de todos los tipos definidos por nombre.
    * Valida la existencia de tipos antes de crear estructuras compuestas.

3.  **Interfaz (REPL):**
    * Un bucle infinito que parsea los comandos del usuario, invoca al gestor y muestra los resultados formateados.

#### Ejecución y Prueba

El proyecto fue desarrollado en **Python 3**. Se requiere la librería `coverage` para validar las pruebas.

```bash
pip install coverage
```

Ejecutar Pruebas Unitarias (Cobertura):

El proyecto incluye una suite de pruebas exhaustiva que valida:

- Cálculos de alineación y padding.
- Estrategias de optimización y empaquetado.
- Uniones y estructuras anidadas.
- Manejo de errores y comandos inválidos.

Para correr los tests y ver el reporte de cobertura (>95%):

```bash
coverage run test.py
coverage report -m
```

Resultado esperado: Ran 4 tests in 0.00xs OK. Esto valida la lógica crítica (padding, reordenamiento, unions) antes de usar la interfaz interactiva.

Ejecutar Simulador:

```bash
python P2.py
```

Ejemplo de Interacción (Traza):

```Plaintext
> ATOMICO char 1 1
Definido ATOMICO char
> ATOMICO int 4 4
Definido ATOMICO int
> ATOMICO double 8 8
Definido ATOMICO double

> STRUCT malo char double char
Definido STRUCT malo

> DESCRIBIR malo
Tipo: malo (StructType)
  [Sin empaquetar] Tamaño: 24, Desperdicio: 14
  [Empaquetado]    Tamaño: 10, Desperdicio: 0
  [Reordenado]     Tamaño: 16, Desperdicio: 6
> SALIR
```

Análisis del ejemplo:

- Sin empaquetar (24 bytes): char(1) + 7 pad + double(8) + char(1) + 7 pad.
- Reordenado (16 bytes): double(8) + char(1) + char(1) + 6 pad.

El algoritmo ordena por alineación descendente, reduciendo el desperdicio en un 57%.
